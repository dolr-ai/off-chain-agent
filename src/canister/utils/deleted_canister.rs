use std::{
    sync::Arc,
    time::{Duration, SystemTime},
};

use anyhow::Context;
use candid::Principal;
use spacetimedb_sdk::Status;
use tokio::sync::broadcast;
use yral_spacetime_bindings::autogenerated::canisters::{add_deleted_canister, DbConnection};

use crate::consts::{DELETED_CANISTERS_MODULE_IDENTITY, STDB_ACCESS_TOKEN, STDB_URL};

pub type ReducerResult = Result<(), String>;

/// (input hash, reducer result)
type BusMessage = (String, ReducerResult);

/// A wrapper around the [`deleted_canisters::DbConnection`] with an internal message bus that allows for async operations
#[derive(Clone)]
pub struct WrappedContextCanisters {
    pub conn: Arc<DbConnection>,
    tx: broadcast::Sender<BusMessage>,
}

impl WrappedContextCanisters {
    pub fn new() -> anyhow::Result<Self> {
        let conn = DbConnection::builder()
            .with_uri(STDB_URL)
            .with_module_name(DELETED_CANISTERS_MODULE_IDENTITY)
            .with_token(Some(STDB_ACCESS_TOKEN.as_str()))
            .build()
            .context("Couldn't connect to the deleted canisters db")?;

        let conn = Arc::new(conn);
        let conn_for_ticking = conn.clone();

        tokio::spawn(async move {
            let Err(err) = conn_for_ticking.run_async().await else {
                return;
            };

            log::error!("connection to deleted canisters index broke with an error: {err:#?}");
        });

        let (tx, _) = broadcast::channel(100);
        let tx_clone = tx.clone();

        conn.reducers
            .on_add_deleted_canister(move |event, _canister_id, user_principal| {
                let res = match event.event.status {
                    Status::Committed => Ok(()),
                    Status::Failed(ref msg) => Err(msg.to_string()),
                    Status::OutOfEnergy => Err("Out of energy".into()),
                };

                // channel must be not be closed
                tx_clone.send((user_principal.clone(), res)).unwrap();
            });

        Ok(Self { conn, tx })
    }

    pub async fn add_deleted_canister(
        &self,
        canister_id: Principal,
        user_principal: Principal,
    ) -> anyhow::Result<ReducerResult> {
        let canister_id_str = canister_id.to_string();
        let user_principal_str = user_principal.to_string();

        let mut rx = self.tx.subscribe();
        self.conn
            .reducers
            .add_deleted_canister(canister_id_str, user_principal_str.clone())
            .context("Couldn't send request to add deleted canister")?;

        let res = loop {
            let (recv_user_principal, data) =
                tokio::time::timeout(Duration::from_secs(5), rx.recv())
                    .await
                    .context("timeout reached before receiving result")??;
            if recv_user_principal == user_principal_str {
                break data;
            }
        };

        Ok(res)
    }
}
